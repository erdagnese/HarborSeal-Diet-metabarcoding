---
title: "Taxonomy_assignment_compare"
author: "Erin D'Agnese"
date: "2025-01-06"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Taxonomy Comparison Tool
 
This script provides functionality to compare taxonomic assignments from different
classification methods and reference databases. It supports:

Classification Methods:
 - Naive Bayes (confidence scores 0-1)
 - VSEARCH (consensus/identity scores 0-1)
 - BLAST (consensus/e-values)
 
Input Files:
 - Expected columns: Feature ID, Taxon, and confidence metric (method-specific)
 - Supports CSV and TSV formats
 - Taxonomy format should be "kingdom;phylum;class;order;family;genus;species" where missing levels are left blank
 - Example: "Chordata;Actinopterygii;Perciformes;;;;" (represents classification to order level)


Output:
 - Original assignments from both methods
 - Final consensus assignment
 - Confidence scores
 - Decision rationale 

# Example usage:

# For naive-bayes classification
naive_bayes_config <- ClassificationConfig(
  method = "naive-bayes",
  score_type = "confidence",
  score_range = c(0, 1),
  high_confidence_threshold = 0.98,
  medium_confidence_threshold = 0.9,
  low_confidence_threshold = 0.7
)

# For vsearch
vsearch_config <- ClassificationConfig(
  method = "vsearch",
  score_type = "consensus",
  score_range = c(0, 1),
  high_confidence_threshold = 0.97,
  medium_confidence_threshold = 0.85,
  low_confidence_threshold = 0.75
)

# For BLAST
blast_config <- ClassificationConfig(
  method = "blast",
  score_type = "evalue",
  score_range = c(0, 1e-5),
  high_confidence_threshold = 1e-100,
  medium_confidence_threshold = 1e-50,
  low_confidence_threshold = 1e-10
)

# Read and merge taxonomy assignments
merged_assignments <- merge_taxonomy_assignments(
  local_path = "path/to/local_taxonomy.tsv",
  universal_path = "path/to/universal_taxonomy.tsv",
  local_method = "naive-bayes",
  universal_method = "naive-bayes"
)

# Compare taxonomic assignments with specified parameters
results <- compare_taxonomic_assignments(
  assignments_df = merged_assignments,
  config = naive_bayes_config
)

# Example with custom column names if needed
custom_results <- compare_taxonomic_assignments(
  assignments_df = merged_assignments,
  config = naive_bayes_config,
  local_tax_col = "local_taxonomy",
  universal_tax_col = "universal_taxonomy",
  local_conf_col = "local_confidence",
  universal_conf_col = "universal_confidence"
)


First call in the R script that streamlines this taxonomic assignment
```{r}
library(tidyverse)
source("Taxonomy_compare_functions.R")
```


First, we need to combine all three assignments and determine what the least common ancestors are between the assignments. The one we believe the most is the local_full for any representatives in that DB, if there are ones that show up in the universal that aren't in the local_full then we should keep those, the prey is there to gain higher resolution assignments when a higher rank matches.
```{r}
source("Functions_three_tax_combine.R")
```


Upload and merge the local and universal taxonomic assignments

For all comparisons, ALWAYS set the second one as the more diverse Reference DB eg the universal if a local v universal assignment is being used
```{r}
library(here)

# Read files
Prey_local_tax <- read_taxonomy(here("data","CorrectionBias","tourmaline-CorBias_18S_16072025","02-output-dada2-pe-unfiltered","01-taxonomy-local-prey","taxonomy.tsv"))
Full_local_tax <- read_taxonomy(here("data","CorrectionBias","tourmaline-CorBias_18S_16072025","02-output-dada2-pe-unfiltered","01-taxonomy-full-local","taxonomy.tsv"))
universal_tax <- read_taxonomy(here("data","CorrectionBias","tourmaline-CorBias_18S_16072025","02-output-dada2-pe-unfiltered","01-taxonomy-universal","taxonomy.tsv"))

# Standardize column names for each input data frame
prey_std <- standardize_taxonomy_cols(Prey_local_tax, "prey")
full_std <- standardize_taxonomy_cols(Full_local_tax, "full")
universal_std <- standardize_taxonomy_cols(universal_tax, "universal")

# Combine taxonomies and calculate LCAs
combined_results <- combine_taxonomies(prey_std, full_std, universal_std)
```

Now we can start determining final taxonomy based on a decision tree


        
```{r}
source("Function_final_taxonomy_decision_tree.R")
```        
        
```{r}
# Apply the decision tree to determine final_taxonomy
final_results <- decision_tree(combined_results)

final_results %>% 
  relocate(final_taxonomy,.after = "universal_confidence") %>% 
  relocate(rule_applied, .after = "final_taxonomy")-> final_results

# Summarize the results
summary_results <- summarize_rules(final_results)

# Print the summary
print(summary_results)


```
Okay now we can pull the final taxonomy, with the featureid to merge with the ASV table for the further analysis
```{r}
final_results %>% 
  dplyr::select(featureid, final_taxonomy) -> final_tax_table

# Function to save taxonomy table with custom descriptor
save_taxonomy_table <- function(final_tax_table, 
                                descriptor = "", 
                                subfolder = "taxonomy_assignments") {
  
  # Create timestamp
  timestamp <- format(Sys.time(), "%Y%m%d_%H%M%S")
  
  # Build filename components
  base_name <- "final_taxonomy"
  descriptor <- ifelse(descriptor == "", "", paste0("_", descriptor))
  
  # Construct full path
  output_path <- here("intermediate-files", subfolder,
                     paste0(base_name, descriptor, "_", timestamp, ".csv"))
  
  # Create directory if needed
  if(!dir.exists(dirname(output_path))) {
    dir.create(dirname(output_path), recursive = TRUE)
  }
  
  # Write the file
  write.csv(
    final_tax_table,
    file = output_path,
    row.names = FALSE,
    )
  
  # Return confirmation
  return(list(
    path = output_path,
    message = paste("Taxonomy table saved to:\n", output_path)
  ))
}

### Usage Examples:
# 1. Basic save (just timestamp)
# save_taxonomy_table(final_tax_table)

# 2. With project descriptor
# save_taxonomy_table(final_tax_table, descriptor = "mammal_diet")

# 3. Custom subfolder
# save_taxonomy_table(final_tax_table, 
#                    descriptor = "marine_fish",
#                    subfolder = "marine_assignments")

# 4. Get path information
# result <- save_taxonomy_table(final_tax_table, "alpine_species")
# cat(result$message)
# file.show(result$path)

# For a specific project
save_taxonomy_table(
  final_tax_table = final_tax_table,
  descriptor = "CorrectionBias", 
  subfolder = "CorrectionBiasRun"
)


```

The decision tree logic is as follows:

# Taxonomy Assignment Decision Tree

## Rule Explanations
# Taxonomy Decision Tree - Complete Rules

### Rule 1: All Three Taxonomies Match Exactly
Logic: If prey_taxonomy == full_taxonomy == universal_taxonomy, use lca_all.

### Rule 2: LCA at Genus/Family Level
Logic: If lca_all_rank is "genus" or "family", use full_taxonomy.

### Rule 3: Universal and Full Local Match
Logic: If full_taxonomy == universal_taxonomy and lca_uni_full_rank != "kingdom", use lca_uni_full.

### Rule 4: Order/Class with Confidence Checks
Logic: If lca_all_rank is "order" or "class":
- If prey == full: Use universal_taxonomy if highest_confidence is universal, else lca_full_prey
- Else if lca_full_prey_rank is "species" or "genus": Use full_taxonomy if highest_confidence is full, else lca_full_prey

### Rule 5: Kingdom-Level with Universal Available
Logic: If lca_uni_prey_rank and lca_full_prey_rank are "kingdom" but lca_uni_full_rank isn't:
- Use universal_taxonomy if universal_confidence > 0.99
- Else use lca_uni_full

### Rule 6: Prey/Full at Kingdom but Universal Better
Logic: If prey_rank and full_rank are "kingdom" and universal_rank isn't, use universal_taxonomy.

### Rule 7: Full Confidence Highest (Not Kingdom)
Logic: If highest_confidence is "full_confidence" and full_rank != "kingdom":
- If universal_confidence < 0.99: Use full_taxonomy
- Else use best available LCA considering universal and full

### Rule 8: Full Confidence at Kingdom Level
Logic: If highest_confidence is "full_confidence" and full_rank == "kingdom":
- Use universal_taxonomy if universal_rank != "kingdom"
- Else use lca_uni_full

### Rule 9: Prey Confidence Highest
Logic: If highest_confidence is "prey_confidence":
- If prey_rank == "kingdom": Use best non-kingdom LCA
- Else: Use confidence-based resolution between prey and full

### Rule 10: Universal Confidence Highest
Logic: If highest_confidence is "universal_confidence" and universal_rank != "kingdom":
- If confidence < 0.9: Use most specific non-kingdom LCA (lca_all, lca_uni_full, or lca_uni_prey)
- Else if universal_rank == "species": Keep universal_taxonomy
- Else: Use most specific non-kingdom LCA

### Rule 11: Universal at Kingdom Level
Logic: If universal_rank == "kingdom":
- Use lca_full_prey if not kingdom
- Else if full_confidence > prey_confidence: Use full_taxonomy
- Else: Use lca_all

### Rule 12: All LCAs at Kingdom Level
Logic: If lca_all_rank == "kingdom":
- Select among lca_uni_full, lca_uni_prey, lca_all
- Choose most specific rank, resolve ties by matching taxonomies

### Rule 13: Final Fallback
Logic: If final_taxonomy still NA, use lca_all.

### Rule Order:
1 → 2 → 3 → 4 → 5 → 6 → 7 → 8 → 9 → 10 → 11 → 12 → 13